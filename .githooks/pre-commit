#!/bin/bash

# Pre-commit hook to squash [auto-commit-hook] commits

# Get the current branch
current_branch=$(git rev-parse --abbrev-ref HEAD)

# Find the most recent non-auto-commit
last_manual_commit=$(git log --format="%H %s" | grep -v "\[auto-commit-hook\]" | head -1 | cut -d' ' -f1)

# Count auto-commits since last manual commit
auto_commit_count=$(git log ${last_manual_commit}..HEAD --format="%s" | grep -c "\[auto-commit-hook\]")

if [ "$auto_commit_count" -gt 0 ]; then
    echo "Found $auto_commit_count auto-commits to squash..."
    
    # Get list of all changed files in auto-commits
    changed_files=$(git diff --name-only ${last_manual_commit}..HEAD | sort | uniq)
    
    # Create a summary of changes
    changes_summary=$(echo "$changed_files" | wc -l | tr -d ' ')
    
    # Get the original commit message (staged)
    original_message=$(git log --format=%B -n 1 --no-commit-id HEAD)
    
    # Reset to last manual commit, keeping changes
    git reset --soft ${last_manual_commit}
    
    # Create new commit with enhanced message
    commit_message="${original_message}

Auto-commits squashed: ${auto_commit_count} commits affecting ${changes_summary} files
Files changed:
$(echo "$changed_files" | sed 's/^/  - /')"
    
    git commit -m "$commit_message"
    
    echo "Successfully squashed auto-commits!"
    exit 0
fi

# If no auto-commits, proceed normally
exit 0